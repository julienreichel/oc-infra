name: Reusable Deploy
on:
  workflow_call:
    inputs:
      app_kind:   { required: true, type: string }
      image_name: { required: true, type: string }
      namespace:  { required: true, type: string }
      host:       { required: false, type: string }
      run_migrations: { required: false, type: boolean, default: false }
    secrets:
      CR_PAT: { required: true }
      KUBECONFIG_CONTENT: { required: true }

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v4

      - name: Setup kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_CONTENT }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Run Database Migrations
        if: ${{ inputs.run_migrations }}
        run: |
          TAG=${{ github.sha }}
          IMAGE="${{ inputs.image_name }}:${TAG}"
          
          # Get the job name from the manifest (since it's hardcoded in each project)
          JOB_NAME=$(grep -E "^  name:" k8s/migration-job.yaml | awk '{print $2}')
          
          echo "Cleaning up previous migration job '$JOB_NAME' if it exists..."
          kubectl delete job $JOB_NAME -n "${{ inputs.namespace }}" --ignore-not-found=true
          kubectl wait --for=delete job/$JOB_NAME -n "${{ inputs.namespace }}" --timeout=60s || true
          
          echo "Running database migrations..."
          
          # Apply the project's migration job with image substitution
          sed "s|IMAGE_PLACEHOLDER|$IMAGE|g" k8s/migration-job.yaml | \
            kubectl -n "${{ inputs.namespace }}" apply -f -
          
          echo "Waiting for pod to start..."
          # Wait for the pod to be created
          for i in {1..60}; do
            POD=$(kubectl -n "${{ inputs.namespace }}" get pods -l job-name=$JOB_NAME -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            [ -n "$POD" ] && break
            sleep 2
          done
          if [ -z "${POD:-}" ]; then
            echo "Pod not created for migration job"; exit 1
          fi
          # Stream logs while job runs
          kubectl -n "${{ inputs.namespace }}" logs -f "job/$JOB_NAME" --all-containers=true & LOG_PID=$!
          
          echo "Waiting for migration job '$JOB_NAME' to complete..."
          kubectl -n "${{ inputs.namespace }}" wait --for=condition=complete job/$JOB_NAME --timeout=300s
          
          # Check job status and logs
          JOB_STATUS=$(kubectl -n "${{ inputs.namespace }}" get job $JOB_NAME -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
          if [ "$JOB_STATUS" != "True" ]; then
            echo "Migration job failed. Job logs:"
            kubectl -n "${{ inputs.namespace }}" logs job/$JOB_NAME --tail=50
            exit 1
          fi
          
          echo "Migration completed successfully"

      - name: Apply Deployment
        run: |
          TAG=${{ github.sha }}
          IMAGE="${{ inputs.image_name }}:${TAG}"
          sed "s|IMAGE_PLACEHOLDER|$IMAGE|g" k8s/deployment.yaml \
            | kubectl -n "${{ inputs.namespace }}" apply -f -

      - name: Apply Service
        run: kubectl -n "${{ inputs.namespace }}" apply -f k8s/service.yaml

      - name: Apply Ingress (frontend only)
        if: ${{ inputs.app_kind == 'frontend' }}
        run: |
          [ -n "${{ inputs.host }}" ] || { echo "host required"; exit 1; }
          sed "s|__HOST__|${{ inputs.host }}|g" k8s/ingress.yaml \
            | kubectl -n "${{ inputs.namespace }}" apply -f -

      - name: Rollout status
        run: |
          DEPLOY_NAME=$(grep -m1 -E '^  name:' k8s/deployment.yaml | awk '{print $2}')
          kubectl -n "${{ inputs.namespace }}" rollout status deploy/$DEPLOY_NAME --timeout=120s || true
