name: Reusable Deploy
on:
  workflow_call:
    inputs:
      app_kind:   { required: true, type: string }
      image_name: { required: true, type: string }
      namespace:  { required: true, type: string }
      host:       { required: false, type: string }
      run_migrations: { required: false, type: boolean, default: false }
    secrets:
      CR_PAT: { required: true }
      KUBECONFIG_CONTENT: { required: true }

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v4

      - name: Setup kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_CONTENT }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Debug cluster/namespace
        run: |
          echo "KUBECONFIG points to:" && kubectl config current-context
          kubectl config get-contexts
          kubectl cluster-info
          echo "NS=${{ inputs.namespace }}"

      - name: Run Database Migrations
        if: ${{ inputs.run_migrations }}
        run: |
          TAG=${{ github.sha }}
          IMAGE="${{ inputs.image_name }}:${TAG}"
          
          # Get the job name from the manifest (since it's hardcoded in each project)
          JOB_NAME=$(grep -E "^  name:" k8s/migration-job.yaml | awk '{print $2}')
          
          echo "Cleaning up previous migration job '$JOB_NAME' if it exists..."
          kubectl delete job $JOB_NAME -n "${{ inputs.namespace }}" --ignore-not-found=true
          kubectl wait --for=delete job/$JOB_NAME -n "${{ inputs.namespace }}" --timeout=60s || true
          
          echo "Running database migrations..."
          
          # Apply the project's migration job with image substitution
          sed "s|IMAGE_PLACEHOLDER|$IMAGE|g" k8s/migration-job.yaml | \
            kubectl -n "${{ inputs.namespace }}" apply -f -
          
          echo "Waiting for migration job '$JOB_NAME' to complete..."
          kubectl -n "${{ inputs.namespace }}" wait --for=condition=complete job/$JOB_NAME --timeout=300s
          
          # Check job status and logs
          JOB_STATUS=$(kubectl -n "${{ inputs.namespace }}" get job $JOB_NAME -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
          if [ "$JOB_STATUS" != "True" ]; then
            echo "Migration job failed. Job logs:"
            kubectl -n "${{ inputs.namespace }}" logs job/$JOB_NAME --tail=50
            exit 1
          fi
          
          echo "Migration completed successfully"

      - name: Create Config Secret for Provider (when deploying client frontend)
        if: ${{ inputs.app_kind == 'frontend' && inputs.host != '' && contains(inputs.namespace, 'client') }}
        run: |
          # Determine provider namespace from client namespace
          PROVIDER_NS="${{ inputs.namespace }}"
          PROVIDER_NS="${PROVIDER_NS/client/provider}"
          
          # Create CLIENT_BASE_URL for provider namespace using the client host
          CLIENT_BASE_URL="https://${{ inputs.host }}/api/"
          
          echo "Creating config secret in provider namespace: $PROVIDER_NS"
          echo "CLIENT_BASE_URL: $CLIENT_BASE_URL"
          
          kubectl -n "$PROVIDER_NS" create secret generic config \
            --from-literal=CLIENT_BASE_URL="$CLIENT_BASE_URL" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Deployment
        run: |
          TAG=${{ github.sha }}
          IMAGE="${{ inputs.image_name }}:${TAG}"
          sed "s|IMAGE_PLACEHOLDER|$IMAGE|g" k8s/deployment.yaml \
            | kubectl -n "${{ inputs.namespace }}" apply -f -

      - name: Apply Service
        run: kubectl -n "${{ inputs.namespace }}" apply -f k8s/service.yaml

      - name: Apply Ingress (frontend only)
        if: ${{ inputs.app_kind == 'frontend' }}
        run: |
          [ -n "${{ inputs.host }}" ] || { echo "host required"; exit 1; }
          sed "s|__HOST__|${{ inputs.host }}|g" k8s/ingress.yaml \
            | kubectl -n "${{ inputs.namespace }}" apply -f -

      - name: Rollout status
        run: |
          DEPLOY_NAME=$(grep -m1 -E '^  name:' k8s/deployment.yaml | awk '{print $2}')
          kubectl -n "${{ inputs.namespace }}" rollout status deploy/$DEPLOY_NAME --timeout=120s || true
